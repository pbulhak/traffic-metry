"""Database module for TrafficMetry vehicle event storage.

This module provides SQLite database functionality for storing and retrieving
vehicle detection events from the TrafficMetry system. Designed for long-term
data preservation with connection lifecycle management and thread-safe operations.
"""

from __future__ import annotations

import asyncio
import json
import logging
import sqlite3
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

from backend.config import DatabaseSettings

logger = logging.getLogger(__name__)


class DatabaseError(Exception):
    """Base database error matching project pattern."""

    def __init__(self, message: str, db_path: str | None = None) -> None:
        super().__init__(message)
        self.db_path = db_path


class DatabaseConnectionError(DatabaseError):
    """Database connection failure."""

    pass


class EventValidationError(DatabaseError):
    """Invalid event data for database storage."""

    pass


class EventDatabase:
    """Vehicle event database manager for long-term data preservation.

    Provides SQLite storage for vehicle detection events generated by
    EventGenerator.create_vehicle_event(). Uses single-connection lifecycle
    pattern with thread-safe operations optimized for continuous 24/7 archiving.

    This database is designed as a write-only archive - it stores all events
    permanently for long-term analysis without any cleanup mechanisms.
    """

    def __init__(self, db_settings: DatabaseSettings) -> None:
        """Initialize event database with configuration settings.

        Args:
            db_settings: Database configuration from backend.config

        Note:
            This method only initializes parameters. Call connect() to establish
            database connection and setup schema.
        """
        self.db_path = Path(db_settings.path)

        # Connection lifecycle management
        self._connection: sqlite3.Connection | None = None

        # Thread-safety lock for consistency
        self._lock = asyncio.Lock()

        # Statistics tracking
        self.saved_count = 0

        # Ensure parent directory exists
        self.db_path.parent.mkdir(parents=True, exist_ok=True)

        logger.info(f"Event database initialized - path: {self.db_path}")
        logger.info("Database configured for long-term data preservation (no cleanup)")

    async def connect(self) -> None:
        """Establish database connection and ensure schema exists.

        This method should be called once during application startup.
        Creates the database file, tables, and indexes if they don't exist.

        Raises:
            DatabaseConnectionError: If database connection or schema creation fails
        """
        try:
            # Create connection with optimized settings
            loop = asyncio.get_event_loop()
            self._connection = await loop.run_in_executor(None, self._create_connection_sync)

            logger.info("Database connection established successfully")

        except Exception as e:
            raise DatabaseConnectionError(
                f"Failed to connect to database: {e}", db_path=str(self.db_path)
            ) from e

    def _create_connection_sync(self) -> sqlite3.Connection:
        """Create and configure SQLite connection synchronously.

        Returns:
            Configured SQLite connection optimized for long-term storage

        Raises:
            sqlite3.Error: If connection creation fails
        """
        conn = sqlite3.connect(str(self.db_path), check_same_thread=False)

        try:
            # Clean journey table with dedicated position columns - journey_id as SINGLE SOURCE OF TRUTH
            conn.execute("""
                CREATE TABLE IF NOT EXISTS vehicle_journeys (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    journey_id TEXT NOT NULL UNIQUE,     -- Global unique journey ID - SINGLE SOURCE OF TRUTH
                    vehicle_type TEXT NOT NULL,          -- VehicleType enum value
                    entry_timestamp REAL NOT NULL,      -- When vehicle entered tracking
                    exit_timestamp REAL,                -- When vehicle exited tracking

                    -- Clean position data (dedicated INTEGER columns)
                    entry_pos_x INTEGER NOT NULL,       -- Entry position X coordinate
                    entry_pos_y INTEGER NOT NULL,       -- Entry position Y coordinate
                    exit_pos_x INTEGER,                 -- Exit position X coordinate
                    exit_pos_y INTEGER,                 -- Exit position Y coordinate

                    movement_direction TEXT,            -- Dynamic movement direction
                    total_detections INTEGER NOT NULL,  -- Total detections for this vehicle
                    best_confidence REAL NOT NULL,      -- Highest confidence detection
                    best_bbox_json TEXT NOT NULL,       -- JSON [x1,y1,x2,y2] of best detection
                    journey_duration_seconds REAL NOT NULL, -- Total journey time
                    best_detection_timestamp REAL NOT NULL, -- Timestamp of best detection

                    created_at REAL NOT NULL DEFAULT (unixepoch())
                )
            """)

            # Create performance indexes for long-term queries

            # Journey table indexes for efficient analytics queries
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_journeys_entry_timestamp ON vehicle_journeys(entry_timestamp)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_journeys_exit_timestamp ON vehicle_journeys(exit_timestamp)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_journeys_vehicle_type ON vehicle_journeys(vehicle_type)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_journeys_duration ON vehicle_journeys(journey_duration_seconds)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_journeys_journey_id ON vehicle_journeys(journey_id)"
            )

            # Position-based indexes for spatial queries
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_entry_position ON vehicle_journeys(entry_pos_x, entry_pos_y)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_exit_position ON vehicle_journeys(exit_pos_x, exit_pos_y)"
            )
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_movement_direction ON vehicle_journeys(movement_direction)"
            )

            # Set performance pragmas optimized for write-heavy workload
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute("PRAGMA synchronous=NORMAL")
            conn.execute("PRAGMA cache_size=-64000")  # 64MB cache
            conn.execute("PRAGMA temp_store=MEMORY")
            conn.execute("PRAGMA mmap_size=268435456")  # 256MB memory-mapped I/O

            conn.commit()
            logger.debug("Database schema and indexes ensured successfully")

            return conn

        except Exception:
            conn.close()
            raise

    async def close(self) -> None:
        """Close database connection.

        This method should be called during application shutdown to ensure
        proper cleanup of database resources.
        """
        if self._connection:
            try:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(None, self._connection.close)
                self._connection = None
                logger.info("Database connection closed successfully")
            except Exception as e:
                logger.error(f"Error closing database connection: {e}")

    async def save_vehicle_journey(self, journey: Any) -> bool:
        """Save complete vehicle journey to database.

        Args:
            journey: VehicleJourney object from VehicleTrackingManager

        Returns:
            True if journey was saved successfully, False otherwise

        Raises:
            DatabaseConnectionError: If database operation fails
        """
        if not self._connection:
            raise DatabaseConnectionError(
                "Database not connected. Call connect() first.", db_path=str(self.db_path)
            )

        try:
            # Prepare clean journey data for database storage (dedicated position columns)
            journey_data = (
                journey.journey_id,
                journey.vehicle_type.value,
                journey.entry_timestamp,
                journey.exit_timestamp,
                # Clean position data as separate integers
                journey.entry_pos_x,
                journey.entry_pos_y,
                journey.exit_pos_x,
                journey.exit_pos_y,
                journey.movement_direction,
                journey.total_detections,
                journey.best_confidence,
                json.dumps(journey.best_bbox),  # Only bbox remains as JSON
                journey.journey_duration_seconds,
                journey.best_detection_timestamp,
            )

            # Thread-safe database save operation
            async with self._lock:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(
                    None, self._save_journey_sync, journey_data, self._connection
                )
                self.saved_count += 1

            logger.debug(
                f"Vehicle journey {journey.journey_id} saved: "
                f"{journey.journey_duration_seconds:.1f}s, "
                f"{journey.total_detections} detections"
            )
            return True

        except Exception as e:
            logger.error(f"Failed to save vehicle journey {journey.journey_id}: {e}")
            return False

    def _save_journey_sync(self, journey_data: tuple, conn: sqlite3.Connection) -> None:
        """Synchronous journey database save operation (for executor).

        Args:
            journey_data: Tuple of journey data for database insertion
            conn: SQLite connection to use for the operation

        Raises:
            DatabaseConnectionError: If database operation fails
        """
        try:
            conn.execute(
                """
                INSERT INTO vehicle_journeys
                (journey_id, vehicle_type, entry_timestamp, exit_timestamp,
                 entry_pos_x, entry_pos_y, exit_pos_x, exit_pos_y,
                 movement_direction, total_detections, best_confidence,
                 best_bbox_json, journey_duration_seconds, best_detection_timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                journey_data,
            )
            conn.commit()

        except sqlite3.Error as e:
            raise DatabaseConnectionError(
                f"Failed to save journey to database: {e}", db_path=str(self.db_path)
            ) from e

    def get_database_stats(self) -> dict[str, Any]:
        """Get database statistics and health information.

        Returns:
            Dictionary with database statistics including properly formatted timestamps
        """
        if not self._connection:
            return {"database_path": str(self.db_path), "error": "Database not connected"}

        try:
            cursor = self._connection.cursor()

            # Get journey count
            cursor.execute("SELECT COUNT(*) FROM vehicle_journeys")
            journey_count = cursor.fetchone()[0]

            # Get oldest and newest journey timestamps
            cursor.execute("""
                SELECT MIN(entry_timestamp) as oldest, MAX(exit_timestamp) as newest
                FROM vehicle_journeys
            """)
            time_range = cursor.fetchone()

            # Format timestamps as ISO strings if they exist
            oldest_journey = None
            newest_journey = None
            if time_range[0]:
                oldest_journey = datetime.fromtimestamp(time_range[0], tz=UTC).isoformat()
            if time_range[1]:
                newest_journey = datetime.fromtimestamp(time_range[1], tz=UTC).isoformat()

            # Get database file size
            db_size = self.db_path.stat().st_size if self.db_path.exists() else 0

            return {
                "database_path": str(self.db_path),
                "journey_count": journey_count,
                "database_size_bytes": db_size,
                "database_size_mb": round(db_size / (1024 * 1024), 2),
                "journeys_saved": self.saved_count,
                "oldest_journey": oldest_journey,
                "newest_journey": newest_journey,
                "data_model": "clean_journeys_only",  # Indicator of new clean model
            }

        except Exception as e:
            logger.error(f"Failed to get database stats: {e}")
            return {"database_path": str(self.db_path), "error": str(e)}

    async def get_last_journey_id(self) -> int:
        """Get the last journey counter from database for ID continuation.

        Returns:
            Last journey counter number, or 0 if no journeys exist
        """
        if not self._connection:
            logger.warning("⚠️ Database not connected for get_last_journey_id, returning 0")
            return 0

        try:

            def _get_last_id_sync(conn: sqlite3.Connection) -> int:
                cursor = conn.cursor()

                # First check total count
                cursor.execute("SELECT COUNT(*) FROM vehicle_journeys")
                total_count = cursor.fetchone()[0]
                logger.debug(f"🔍 Database contains {total_count} total journeys")

                # Get the most recent journey_id
                cursor.execute("""
                    SELECT journey_id FROM vehicle_journeys
                    WHERE journey_id LIKE 'JOURNEY_%'
                    ORDER BY id DESC LIMIT 1
                """)
                result = cursor.fetchone()

                if result and result[0]:
                    # Extract number from "JOURNEY_000123"
                    try:
                        journey_id = result[0]
                        logger.debug(f"🔍 Found most recent journey_id: '{journey_id}'")

                        if "_" in journey_id:
                            counter_str = journey_id.split("_")[-1]
                            counter_value = int(counter_str)
                            logger.info(
                                f"📊 Parsed counter value: {counter_value} from journey_id '{journey_id}'"
                            )
                            return counter_value
                        else:
                            logger.warning(
                                f"⚠️ Journey ID format unexpected: '{journey_id}' (no underscore)"
                            )
                    except (ValueError, IndexError) as e:
                        logger.warning(f"⚠️ Failed to parse journey_id '{result[0]}': {e}")
                        return 0
                else:
                    logger.info("📊 No journeys found in database, starting from 0")
                    return 0

                return 0

            loop = asyncio.get_event_loop()
            last_id = await loop.run_in_executor(None, _get_last_id_sync, self._connection)

            logger.info(
                f"✅ Retrieved last journey ID counter from database: {last_id} (next will be {last_id + 1})"
            )
            return last_id

        except Exception as e:
            logger.error(f"💥 Error getting last journey ID from database: {e}")
            return 0
