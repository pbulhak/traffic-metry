"""Database module for TrafficMetry vehicle event storage.

This module provides SQLite database functionality for storing and retrieving
vehicle detection events from the TrafficMetry system. Designed for long-term
data preservation with connection lifecycle management and thread-safe operations.
"""

from __future__ import annotations

import asyncio
import json
import logging
import sqlite3
from datetime import UTC, datetime
from pathlib import Path
from typing import Any

from backend.config import DatabaseSettings

logger = logging.getLogger(__name__)


class DatabaseError(Exception):
    """Base database error matching project pattern."""

    def __init__(self, message: str, db_path: str | None = None) -> None:
        super().__init__(message)
        self.db_path = db_path


class DatabaseConnectionError(DatabaseError):
    """Database connection failure."""

    pass


class EventValidationError(DatabaseError):
    """Invalid event data for database storage."""

    pass


class EventDatabase:
    """Vehicle event database manager for long-term data preservation.

    Provides SQLite storage for vehicle detection events generated by
    EventGenerator.create_vehicle_event(). Uses single-connection lifecycle
    pattern with thread-safe operations optimized for continuous 24/7 archiving.

    This database is designed as a write-only archive - it stores all events
    permanently for long-term analysis without any cleanup mechanisms.
    """

    def __init__(self, db_settings: DatabaseSettings) -> None:
        """Initialize event database with configuration settings.

        Args:
            db_settings: Database configuration from backend.config

        Note:
            This method only initializes parameters. Call connect() to establish
            database connection and setup schema.
        """
        self.db_path = Path(db_settings.path)

        # Connection lifecycle management
        self._connection: sqlite3.Connection | None = None

        # Thread-safety lock for consistency
        self._lock = asyncio.Lock()

        # Statistics tracking
        self.saved_count = 0

        # Ensure parent directory exists
        self.db_path.parent.mkdir(parents=True, exist_ok=True)

        logger.info(f"Event database initialized - path: {self.db_path}")
        logger.info("Database configured for long-term data preservation (no cleanup)")

    async def connect(self) -> None:
        """Establish database connection and ensure schema exists.

        This method should be called once during application startup.
        Creates the database file, tables, and indexes if they don't exist.

        Raises:
            DatabaseConnectionError: If database connection or schema creation fails
        """
        try:
            # Create connection with optimized settings
            loop = asyncio.get_event_loop()
            self._connection = await loop.run_in_executor(None, self._create_connection_sync)

            logger.info("Database connection established successfully")

        except Exception as e:
            raise DatabaseConnectionError(
                f"Failed to connect to database: {e}", db_path=str(self.db_path)
            ) from e

    def _create_connection_sync(self) -> sqlite3.Connection:
        """Create and configure SQLite connection synchronously.

        Returns:
            Configured SQLite connection optimized for long-term storage

        Raises:
            sqlite3.Error: If connection creation fails
        """
        conn = sqlite3.connect(str(self.db_path), check_same_thread=False)

        try:
            # Legacy table for backward compatibility (detection-based events)
            conn.execute("""
                CREATE TABLE IF NOT EXISTS vehicle_events (
                    event_id TEXT PRIMARY KEY,           -- event["eventId"]
                    timestamp REAL NOT NULL,             -- event["timestamp"] as Unix timestamp
                    vehicle_id TEXT NOT NULL,            -- event["vehicleId"]
                    vehicle_type TEXT NOT NULL,          -- event["vehicleType"]
                    direction TEXT,                      -- event["movement"]["direction"]
                    lane INTEGER,                        -- event["movement"]["lane"]
                    x1 INTEGER NOT NULL,                 -- event["position"]["boundingBox"]["x1"]
                    y1 INTEGER NOT NULL,                 -- event["position"]["boundingBox"]["y1"]
                    x2 INTEGER NOT NULL,                 -- event["position"]["boundingBox"]["x2"]
                    y2 INTEGER NOT NULL,                 -- event["position"]["boundingBox"]["y2"]
                    confidence REAL NOT NULL,            -- event["analytics"]["confidence"]
                    created_at REAL NOT NULL DEFAULT (unixepoch())
                )
            """)

            # Simplified journey table for MVP requirements
            conn.execute("""
                CREATE TABLE IF NOT EXISTS vehicle_journeys (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    track_id INTEGER NOT NULL,           -- ByteTrack tracking ID
                    journey_id TEXT,                     -- Global unique journey ID
                    vehicle_type TEXT NOT NULL,          -- VehicleType enum value
                    entry_timestamp REAL NOT NULL,      -- When vehicle entered tracking
                    exit_timestamp REAL,                -- When vehicle exited tracking
                    entry_position_json TEXT,           -- JSON [x,y] entry position
                    exit_position_json TEXT,            -- JSON [x,y] exit position
                    movement_direction TEXT,            -- Dynamic movement direction
                    direction_confidence REAL,          -- Direction confidence (0-1)
                    total_movement_pixels REAL,         -- Total distance traveled
                    average_speed_pixels_per_second REAL, -- Average speed
                    displacement_vector_json TEXT,      -- JSON [dx,dy] displacement
                    total_detections INTEGER NOT NULL,  -- Total detections for this vehicle
                    best_confidence REAL NOT NULL,      -- Highest confidence detection
                    best_bbox_json TEXT NOT NULL,       -- JSON [x1,y1,x2,y2] of best detection
                    journey_duration_seconds REAL NOT NULL, -- Total journey time
                    best_detection_timestamp REAL NOT NULL, -- Timestamp of best detection
                    
                    -- Legacy columns (kept for backward compatibility but can be NULL)
                    entry_lane INTEGER,                 -- Lane where vehicle entered (legacy)
                    exit_lane INTEGER,                  -- Lane where vehicle exited (legacy)
                    
                    created_at REAL NOT NULL DEFAULT (unixepoch())
                )
            """)

            # Create performance indexes for long-term queries
            # Legacy table indexes
            conn.execute("CREATE INDEX IF NOT EXISTS idx_timestamp ON vehicle_events(timestamp)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_vehicle_id ON vehicle_events(vehicle_id)")

            # Journey table indexes for efficient analytics queries
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_entry_timestamp ON vehicle_journeys(entry_timestamp)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_exit_timestamp ON vehicle_journeys(exit_timestamp)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_vehicle_type ON vehicle_journeys(vehicle_type)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_track_id ON vehicle_journeys(track_id)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_duration ON vehicle_journeys(journey_duration_seconds)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_entry_lane ON vehicle_journeys(entry_lane)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_journeys_exit_lane ON vehicle_journeys(exit_lane)")
            conn.execute(
                "CREATE INDEX IF NOT EXISTS idx_vehicle_type ON vehicle_events(vehicle_type)"
            )
            conn.execute("CREATE INDEX IF NOT EXISTS idx_created_at ON vehicle_events(created_at)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_direction ON vehicle_events(direction)")
            conn.execute("CREATE INDEX IF NOT EXISTS idx_lane ON vehicle_events(lane)")

            # Set performance pragmas optimized for write-heavy workload
            conn.execute("PRAGMA journal_mode=WAL")
            conn.execute("PRAGMA synchronous=NORMAL")
            conn.execute("PRAGMA cache_size=-64000")  # 64MB cache
            conn.execute("PRAGMA temp_store=MEMORY")
            conn.execute("PRAGMA mmap_size=268435456")  # 256MB memory-mapped I/O

            conn.commit()
            logger.debug("Database schema and indexes ensured successfully")

            return conn

        except Exception:
            conn.close()
            raise

    async def close(self) -> None:
        """Close database connection.

        This method should be called during application shutdown to ensure
        proper cleanup of database resources.
        """
        if self._connection:
            try:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(None, self._connection.close)
                self._connection = None
                logger.info("Database connection closed successfully")
            except Exception as e:
                logger.error(f"Error closing database connection: {e}")

    async def save_event(self, event: dict) -> bool:
        """Save vehicle event from EventGenerator.create_vehicle_event().

        Args:
            event: Event dictionary in API v2.3 format from EventGenerator

        Returns:
            True if event was saved successfully, False otherwise

        Raises:
            EventValidationError: If event data is invalid
            DatabaseConnectionError: If database operation fails
        """
        if not self._connection:
            raise DatabaseConnectionError(
                "Database not connected. Call connect() first.", db_path=str(self.db_path)
            )

        try:
            # Validate event structure
            required_keys = [
                "eventId",
                "timestamp",
                "vehicleId",
                "vehicleType",
                "movement",
                "position",
                "analytics",
            ]
            for key in required_keys:
                if key not in event:
                    raise EventValidationError(f"Missing required event key: {key}")

            # Extract data from nested event structure
            movement = event["movement"]
            position = event["position"]["boundingBox"]
            analytics = event["analytics"]

            # Validate nested structure
            if "direction" not in movement or "lane" not in movement:
                raise EventValidationError("Invalid movement data in event")
            if not all(k in position for k in ["x1", "y1", "x2", "y2"]):
                raise EventValidationError("Invalid position data in event")
            if "confidence" not in analytics:
                raise EventValidationError("Invalid analytics data in event")

            # Convert timestamp string to Unix timestamp for storage
            if isinstance(event["timestamp"], str):
                # Parse ISO format timestamp to Unix timestamp
                dt = datetime.fromisoformat(event["timestamp"].replace("Z", "+00:00"))
                unix_timestamp = dt.timestamp()
            else:
                # Assume it's already a Unix timestamp
                unix_timestamp = float(event["timestamp"])

            # Prepare data for database insertion
            event_data = (
                event["eventId"],
                unix_timestamp,
                event["vehicleId"],
                event["vehicleType"],
                movement["direction"],
                movement["lane"],
                position["x1"],
                position["y1"],
                position["x2"],
                position["y2"],
                analytics["confidence"],
            )

            # Thread-safe database save operation
            async with self._lock:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(
                    None, self._save_event_sync, event_data, self._connection
                )
                self.saved_count += 1

            logger.debug(f"Event {event['eventId']} permanently archived to database")
            return True

        except (EventValidationError, DatabaseConnectionError):
            # Re-raise validation and connection errors
            raise
        except Exception as e:
            logger.error(f"Unexpected error saving event {event.get('eventId', 'unknown')}: {e}")
            return False

    def _save_event_sync(self, event_data: tuple, conn: sqlite3.Connection) -> None:
        """Synchronous database save operation (for executor).

        Args:
            event_data: Tuple of event data for database insertion
            conn: SQLite connection to use for the operation

        Raises:
            DatabaseConnectionError: If database operation fails
        """
        try:
            conn.execute(
                """
                INSERT INTO vehicle_events
                (event_id, timestamp, vehicle_id, vehicle_type, direction,
                 lane, x1, y1, x2, y2, confidence)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                event_data,
            )
            conn.commit()

        except sqlite3.Error as e:
            raise DatabaseConnectionError(
                f"Failed to save event to database: {e}", db_path=str(self.db_path)
            ) from e

    async def save_vehicle_journey(self, journey: Any) -> bool:
        """Save complete vehicle journey to database.

        Args:
            journey: VehicleJourney object from VehicleTrackingManager

        Returns:
            True if journey was saved successfully, False otherwise

        Raises:
            DatabaseConnectionError: If database operation fails
        """
        if not self._connection:
            raise DatabaseConnectionError(
                "Database not connected. Call connect() first.", db_path=str(self.db_path)
            )

        try:
            # Prepare enhanced journey data for database storage (position-based)
            journey_data = (
                journey.track_id,
                journey.journey_id,
                journey.vehicle_type.value,
                journey.entry_timestamp,
                journey.exit_timestamp,
                json.dumps(journey.entry_position),   # Store position as JSON
                json.dumps(journey.exit_position),    # Store position as JSON
                journey.movement_direction,
                journey.direction_confidence,
                journey.total_movement_pixels,
                journey.average_speed_pixels_per_second,
                json.dumps(journey.displacement_vector),  # Store as JSON
                journey.total_detections,
                journey.best_confidence,
                json.dumps(journey.best_bbox),       # Store bbox as JSON array
                journey.journey_duration_seconds,
                journey.best_detection_timestamp,
            )

            # Thread-safe database save operation
            async with self._lock:
                loop = asyncio.get_event_loop()
                await loop.run_in_executor(
                    None, self._save_journey_sync, journey_data, self._connection
                )
                self.saved_count += 1

            logger.debug(
                f"Vehicle journey {journey.track_id} saved: "
                f"{journey.journey_duration_seconds:.1f}s, "
                f"{journey.total_detections} detections"
            )
            return True

        except Exception as e:
            logger.error(f"Failed to save vehicle journey {journey.track_id}: {e}")
            return False

    def _save_journey_sync(self, journey_data: tuple, conn: sqlite3.Connection) -> None:
        """Synchronous journey database save operation (for executor).

        Args:
            journey_data: Tuple of journey data for database insertion
            conn: SQLite connection to use for the operation

        Raises:
            DatabaseConnectionError: If database operation fails
        """
        try:
            conn.execute(
                """
                INSERT INTO vehicle_journeys
                (track_id, journey_id, vehicle_type, entry_timestamp, exit_timestamp, 
                 entry_position_json, exit_position_json, movement_direction, 
                 direction_confidence, total_movement_pixels, average_speed_pixels_per_second,
                 displacement_vector_json, total_detections, best_confidence,
                 best_bbox_json, journey_duration_seconds, best_detection_timestamp)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?, ?)
            """,
                journey_data,
            )
            conn.commit()

        except sqlite3.Error as e:
            raise DatabaseConnectionError(
                f"Failed to save journey to database: {e}", db_path=str(self.db_path)
            ) from e

    async def get_recent_events(self, limit: int = 100) -> list[dict]:
        """Retrieve recent events in original API v2.3 format.

        Args:
            limit: Maximum number of events to retrieve

        Returns:
            List of event dictionaries in API format with proper ISO timestamps

        Raises:
            DatabaseConnectionError: If database query fails
        """
        if not self._connection:
            raise DatabaseConnectionError(
                "Database not connected. Call connect() first.", db_path=str(self.db_path)
            )

        try:
            loop = asyncio.get_event_loop()
            events = await loop.run_in_executor(
                None, self._get_events_sync, limit, self._connection
            )

            # Convert database rows back to API v2.3 format with proper timestamp formatting
            formatted_events = []
            for row in events:
                # Convert Unix timestamp back to ISO format string
                timestamp_iso = datetime.fromtimestamp(row["timestamp"], tz=UTC).isoformat()

                event = {
                    "eventId": row["event_id"],
                    "timestamp": timestamp_iso,
                    "vehicleId": row["vehicle_id"],
                    "vehicleType": row["vehicle_type"],
                    "movement": {"direction": row["direction"], "lane": row["lane"]},
                    "vehicleColor": {"hex": None, "name": None},
                    "position": {
                        "boundingBox": {
                            "x1": row["x1"],
                            "y1": row["y1"],
                            "x2": row["x2"],
                            "y2": row["y2"],
                        }
                    },
                    "analytics": {"confidence": row["confidence"], "estimatedSpeedKph": None},
                }
                formatted_events.append(event)

            return formatted_events

        except Exception as e:
            raise DatabaseConnectionError(
                f"Failed to retrieve events from database: {e}", db_path=str(self.db_path)
            ) from e

    def _get_events_sync(self, limit: int, conn: sqlite3.Connection) -> list[dict]:
        """Synchronous database query operation (for executor).

        Args:
            limit: Maximum number of events to retrieve
            conn: SQLite connection to use for the operation

        Returns:
            List of event data as dictionaries
        """
        conn.row_factory = sqlite3.Row  # Enable dict-like row access
        cursor = conn.cursor()

        cursor.execute(
            """
            SELECT event_id, timestamp, vehicle_id, vehicle_type, direction,
                   lane, x1, y1, x2, y2, confidence, created_at
            FROM vehicle_events
            ORDER BY created_at DESC
            LIMIT ?
        """,
            (limit,),
        )

        return [dict(row) for row in cursor.fetchall()]

    def get_database_stats(self) -> dict[str, Any]:
        """Get database statistics and health information.

        Returns:
            Dictionary with database statistics including properly formatted timestamps
        """
        if not self._connection:
            return {"database_path": str(self.db_path), "error": "Database not connected"}

        try:
            cursor = self._connection.cursor()

            # Get record count
            cursor.execute("SELECT COUNT(*) FROM vehicle_events")
            record_count = cursor.fetchone()[0]

            # Get oldest and newest timestamps
            cursor.execute("""
                SELECT MIN(created_at) as oldest, MAX(created_at) as newest
                FROM vehicle_events
            """)
            time_range = cursor.fetchone()

            # Format timestamps as ISO strings if they exist
            oldest_event = None
            newest_event = None
            if time_range[0]:
                oldest_event = datetime.fromtimestamp(time_range[0], tz=UTC).isoformat()
            if time_range[1]:
                newest_event = datetime.fromtimestamp(time_range[1], tz=UTC).isoformat()

            # Get database file size
            db_size = self.db_path.stat().st_size if self.db_path.exists() else 0

            return {
                "database_path": str(self.db_path),
                "record_count": record_count,
                "database_size_bytes": db_size,
                "database_size_mb": round(db_size / (1024 * 1024), 2),
                "events_saved": self.saved_count,
                "oldest_event": oldest_event,
                "newest_event": newest_event,
                "preservation_mode": "long_term_archive",  # Indicator of no cleanup
            }

        except Exception as e:
            logger.error(f"Failed to get database stats: {e}")
            return {"database_path": str(self.db_path), "error": str(e)}
